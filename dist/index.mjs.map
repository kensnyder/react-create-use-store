{"version":3,"file":"index.mjs","sources":["../src/createStore/createStore.js","../src/useStore/useStore.js"],"sourcesContent":["// an internal counter for stores\nlet storeIdx = 0;\n// list of middleware functions that augment actions\nconst middlewares = [];\n\n/**\n * Creates a new store\n * @param {Object} [config] - An object containing the store setup\n * @property {Object} [config.state] - The store's initial state. It can be of any type.\n * @property {Object} [config.actions] - Named functions that can be dispatched by name and payload.\n * @property {Boolean} [config.autoReset] - If true, reset the store when all consumer components unmount\n * @property {Function} [config.onFirstUse] - Callback the very first time a component calls useStore()\n * @property {Function} [config.afterFirstMount] - Callback when a useStore() component mounts when no other are mounted\n * @property {Function} [config.afterEachMount] - Callback every time a component first calls useStore()\n * @property {Function} [config.afterEachUnmount] - Callback when any useStore() component unmounts\n * @property {Function} [config.afterLastUnmount] - Callback when all user components unmount\n * @property {Function} [config.onMiddlewareError] - Callback when a middleware throws an exception\n * @property {String} [config.id] - The id string which middleware can use to tell stores apart\n * @return {Object} store - Info and methods for working with the store\n * @property {String} store.id - The id or number of the store\n * @property {Number} store.idx - The index order of the store in order of definition\n * @property {Function} store.addActions - Register more actions for this store\n * @property {Function} store.reset - Reset the store's state to its original value\n * @property {Object} store.actions - Methods that can be called to affect state\n * @property {Function} store._subscribe - A method to add a setState callback that should be notified on changes\n * @property {Function} store._unsubscribe - A method to remove a setState callback\n * @property {Number} store._usedCount - The number of components that have ever used this store\n */\nexport function createStore({\n  state = {},\n  actions = {},\n  autoReset = false,\n  onFirstUse = () => {},\n  afterFirstMount = () => {},\n  afterEachMount = () => {},\n  afterEachUnmount = () => {},\n  afterLastUnmount = () => {},\n  onMiddlewareError = () => {},\n  id = null,\n}) {\n  // list of setters subscribed to changes\n  let _setters = [];\n\n  // define the store\n  const store = {\n    // an identifier that middleware may be interested\n    id: String(id || `store-${storeIdx}`),\n    // internal counter\n    idx: storeIdx,\n    // A store's state can be reset to its original value\n    reset: () => _setAll(state),\n    // add more action functions to this state\n    addActions,\n    state: state,\n    setState: _setAll,\n    // private: functions that will act on state\n    actions: {},\n    // private: useStore() can subscribe to all store changes\n    _subscribe,\n    // private: useStore() can unsubscribe from changes\n    _unsubscribe,\n    // private: A count of the number of times this store has ever been used\n    _usedCount: 0,\n  };\n\n  storeIdx++;\n\n  // add any actions that are given at this time\n  addActions(actions);\n\n  // return this store\n  return store;\n\n  //\n  // functions only beyond this point\n  //\n\n  /**\n   * Add action functions to this state\n   * @param {Object} actions\n   */\n  function addActions(actions) {\n    // build the actions, allowing for middleware\n    Object.keys(actions).forEach(name => {\n      const action = actions[name];\n      store.actions[name] = (...args) => {\n        let idx = 0;\n        // function to invoke next middleware or to invoke action\n        let next = () => {\n          idx++;\n          const middleware = middlewares[idx - 1];\n          if (middleware) {\n            // one or more middlewares left to run\n            const input = { store, action, name, args };\n            try {\n              // call this middleware\n              middleware(input, next);\n            } catch (error) {\n              const context = {\n                error,\n                middleware,\n                input,\n              };\n              console.error(\n                `react-create-use-store: middleware failed during action \"${name}.\"`,\n                context\n              );\n              onMiddlewareError(context);\n            }\n          } else {\n            // all middlewares have run; call the action\n            action([state, _setAll], ...args);\n          }\n        };\n        // kick off action\n        next();\n      };\n    });\n  }\n\n  /**\n   * Add a setState function to notify when state changes\n   * @param {Function} setState - Function returned from the useState() inside useStore()\n   * @private\n   */\n  function _subscribe(setState) {\n    if (store._usedCount++ === 0) {\n      onFirstUse(store);\n    }\n    if (_setters.length === 0) {\n      afterFirstMount(store);\n    }\n    if (_setters.indexOf(setState) === -1) {\n      _setters.push(setState);\n      afterEachMount(store);\n    }\n  }\n\n  /**\n   * Remove a setState function from notification when state changes\n   * @param {Function} setState - Function returned from the useState() inside useStore()\n   * @private\n   */\n  function _unsubscribe(setState) {\n    _setters = _setters.filter(setter => setter !== setState);\n    afterEachUnmount(store);\n    if (_setters.length === 0) {\n      if (autoReset) {\n        store.reset();\n      }\n      afterLastUnmount(store);\n    }\n  }\n\n  /**\n   * Notify each of the setState functions of the new state\n   * @param {*} newState\n   * @private\n   */\n  function _setAll(newState) {\n    if (typeof newState === 'function') {\n      // TODO: queue changes for next tick?\n      newState = newState(store.state);\n    }\n    store.state = newState;\n    _setters.forEach(setter => setter(newState));\n  }\n}\n\n/**\n * Add a middleware function to run for every action across every store\n * @param {Function} handler\n * Middleware functions receive 2 arguments:\n * {Object} info => {\n * \t\tstore,     // the store object\n * \t\tstate,     // the store's current state\n * \t\tsetState,  // a function to update the current state\n * \t\taction,    // the original action function passed to createStore()\n * \t\tname,      // the name of the action\n * \t\targs       // the args passed to the action function\n * }\n * {Function} next  A function to call when the middleware wishes the next middleware to run\n */\nexport function addMiddleware(handler) {\n  middlewares.push(handler);\n}\n\n/**\n * Remove a middleware function that was added with addMiddleware()\n * @param {Function} handler\n */\nexport function removeMiddleware(handler) {\n  const idx = middlewares.indexOf(handler);\n  if (idx > -1) {\n    middlewares.splice(idx, 1);\n  }\n}\n","import { useState, useEffect, useDebugValue } from 'react';\n\n/**\n * @param {Object} store - A store created with createStore()\n * @return {Object} - tools for working with the store\n * @property {*} state - The values in the store\n * @property {Object} actions - functions defined by createStore\n * @property {Function} reset - function to reset the store's state to its initial value\n */\nexport function useStore(store) {\n  const [_, setState] = useState(store.state);\n\n  // store._setState(state);\n  useDebugValue(store);\n\n  useEffect(() => {\n    store._subscribe(setState);\n    return () => store._unsubscribe(setState);\n  }, [store]);\n\n  return {\n    state: store.state,\n    actions: store.actions,\n    reset: store.reset,\n  };\n}\n"],"names":["let","storeIdx","middlewares","createStore","_setters","store","id","String","idx","reset","_setAll","state","addActions","setState","actions","_usedCount","onFirstUse","length","afterFirstMount","indexOf","push","afterEachMount","filter","setter","afterEachUnmount","autoReset","afterLastUnmount","Object","keys","forEach","name","action","next","middleware","input","args","error","context","console","onMiddlewareError","newState","addMiddleware","handler","removeMiddleware","splice","useStore","useState","useDebugValue","useEffect","_subscribe","_unsubscribe"],"mappings":"mEACAA,IAAIC,EAAW,EAETC,EAAc,GAyBb,SAASC,kCACN,mCACE,sCACE,yVAOP,UAGDC,EAAW,GAGTC,EAAQ,CAEZC,GAAIC,OAAOD,YAAeL,GAE1BO,IAAKP,EAELQ,wBAAaC,EAAQC,eAErBC,EACAD,MAAOA,EACPE,SAAUH,EAEVI,QAAS,uBAqESD,GACS,GAAvBR,EAAMU,cACRC,EAAWX,GAEW,IAApBD,EAASa,QACXC,EAAgBb,IAEkB,IAAhCD,EAASe,QAAQN,KACnBT,EAASgB,KAAKP,GACdQ,EAAehB,2BASGQ,GACpBT,EAAWA,EAASkB,gBAAOC,UAAUA,IAAWV,IAChDW,EAAiBnB,GACO,IAApBD,EAASa,SACPQ,GACFpB,EAAMI,QAERiB,EAAiBrB,KAxFnBU,WAAY,UAGdd,IAGAW,EAAWE,GAGJT,WAUEO,EAAWE,GAElBa,OAAOC,KAAKd,GAASe,iBAAQC,OACrBC,EAASjB,EAAQgB,GACvBzB,EAAMS,QAAQgB,yEACRtB,EAAM,EAENwB,iBAEIC,EAAa/B,IADnBM,EACqC,MACjCyB,EAAY,KAERC,EAAQ,OAAE7B,SAAO0B,OAAQD,OAAMK,OAGnCF,EAAWC,EAAOF,GAClB,MAAOI,OACDC,EAAU,OACdD,aACAH,QACAC,GAEFI,QAAQF,kEACsDN,OAC5DO,GAEFE,EAAkBF,SAIpBN,gBAAO,CAACpB,EAAOD,WAAayB,KAIhCH,gBA4CGtB,EAAQ8B,GACS,mBAAbA,IAETA,EAAWA,EAASnC,EAAMM,QAE5BN,EAAMM,MAAQ6B,EACdpC,EAASyB,iBAAQN,UAAUA,EAAOiB,MAkB/B,SAASC,EAAcC,GAC5BxC,EAAYkB,KAAKsB,GAOZ,SAASC,EAAiBD,OACzBlC,EAAMN,EAAYiB,QAAQuB,GAC5BlC,GAAO,GACTN,EAAY0C,OAAOpC,EAAK,GCzLrB,SAASqC,EAASxC,SACDyC,EAASzC,EAAMM,iBAGrCoC,EAAc1C,GAEd2C,oBACE3C,EAAM4C,WAAWpC,qBACJR,EAAM6C,aAAarC,KAC/B,CAACR,IAEG,CACLM,MAAON,EAAMM,MACbG,QAAST,EAAMS,QACfL,MAAOJ,EAAMI"}