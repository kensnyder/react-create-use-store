{"version":3,"file":"index.umd.js","sources":["../src/createStore/createStore.js","../src/useStore/useStore.js"],"sourcesContent":["// an internal counter for stores\nlet storeIdx = 1;\n\n/**\n * Creates a new store\n * @param {Object} [config] - An object containing the store setup\n * @property {Object} [config.state] - The store's initial state. It can be of any type.\n * @property {Object} [config.actions] - Named functions that can be dispatched by name and payload.\n * @property {Boolean} [config.autoReset] - If true, reset the store when all consumer components unmount\n * @property {Function} [config.onFirstUse] - Callback the very first time a component calls useStore()\n * @property {Function} [config.afterFirstMount] - Callback when a useStore() component mounts when no other are mounted\n * @property {Function} [config.afterEachMount] - Callback every time a component first calls useStore()\n * @property {Function} [config.afterEachUnmount] - Callback when any useStore() component unmounts\n * @property {Function} [config.afterLastUnmount] - Callback when all user components unmount\n * @property {String} [config.id] - The id string for debugging\n * @return {Object} store - Info and methods for working with the store\n * @property {Function} store.state - the current state value\n * @property {Object} store.actions - Methods that can be called to affect state\n * @property {Function} store.setState - function to set a new state value\n * @property {Function} store.nextState - function that returns a Promise that resolves on next state value\n * @property {Function} store.reset - Reset the store's state to its original value\n * @property {String} store.id - The id or number of the store\n * @property {Number} store.idx - The index order of the store in order of definition\n * @property {Function} store._subscribe - A method to add a setState callback that should be notified on changes\n * @property {Function} store._unsubscribe - A method to remove a setState callback\n * @property {Number} store._usedCount - The number of components that have ever used this store\n */\nexport function createStore({\n  state = {},\n  actions = {},\n  autoReset = false,\n  onFirstUse = () => {},\n  afterFirstMount = () => {},\n  afterEachMount = () => {},\n  afterEachUnmount = () => {},\n  afterLastUnmount = () => {},\n  id = null,\n}) {\n  // list of setState functions for Components that use this store\n  let _setters = [];\n  // list of resolve functions for awaiting nextState\n  let _nextStateResolvers = [];\n\n  // define the store object,\n  // which should normally not be consumed directly\n  const store = {\n    // A store's state can be reset to its original value\n    reset: () => _setAll(state),\n    // the value represented\n    state: state,\n    // set the state and update all components that use this store\n    setState: _setAll,\n    // return a Promise that will be resolve on next state change\n    nextState,\n    // functions that act on state\n    actions,\n    // an identifier for debugging\n    id: String(id || `store-${storeIdx}`),\n    // internal counter\n    idx: storeIdx++,\n    // private: useStore() can subscribe to all store changes\n    _subscribe,\n    // private: useStore() can unsubscribe from changes\n    _unsubscribe,\n    // private: A count of the number of times this store has ever been used\n    _usedCount: 0,\n  };\n\n  // return this store\n  return store;\n\n  //\n  // functions only beyond this point\n  //\n\n  function nextState() {\n    return new Promise(resolve => {\n      _nextStateResolvers.push(resolve);\n    });\n  }\n\n  /**\n   * Add a setState function to notify when state changes\n   * @param {Function} setState - Function returned from the useState() inside useStore()\n   * @private\n   */\n  function _subscribe(setState) {\n    if (store._usedCount++ === 0) {\n      onFirstUse();\n    }\n    if (_setters.length === 0) {\n      afterFirstMount();\n    }\n    if (_setters.indexOf(setState) === -1) {\n      _setters.push(setState);\n      afterEachMount();\n    }\n  }\n\n  /**\n   * Remove a setState function from notification when state changes\n   * @param {Function} setState - Function returned from the useState() inside useStore()\n   * @private\n   */\n  function _unsubscribe(setState) {\n    _setters = _setters.filter(setter => setter !== setState);\n    afterEachUnmount();\n    if (_setters.length === 0) {\n      if (autoReset) {\n        store.reset();\n      }\n      afterLastUnmount();\n    }\n  }\n\n  /**\n   * Notify each of the setState functions of the new state\n   * @param {*} newState\n   * @private\n   */\n  function _setAll(newState) {\n    if (typeof newState === 'function') {\n      newState = newState(store.state);\n    }\n    // queue state update for next tick\n    // see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask\n    Promise.resolve()\n      .then(() => {\n        store.state = newState;\n        _setters.forEach(setter => setter(store.state));\n        _nextStateResolvers.forEach(resolver => resolver(store.state));\n        _nextStateResolvers = [];\n      })\n      .catch(e => {\n        throw e;\n      });\n  }\n}\n","import { useState, useEffect, useDebugValue } from 'react';\n\n/**\n * @param {Object} store - A store created with createStore()\n * @return {Object} - tools for working with the store\n * @property {*} state - The value in the store\n * @property {Object} actions - functions defined by createStore\n * @property {Function} reset - function to reset the store's state to its initial value\n * @property {Function} nextState - function that returns a Promise that resolves on next state value\n */\nexport function useStore(store) {\n  const [, setState] = useState(store.state);\n\n  useDebugValue(store);\n\n  useEffect(() => {\n    store._subscribe(setState);\n    return () => store._unsubscribe(setState);\n  }, [store]);\n\n  return {\n    state: store.state,\n    actions: store.actions,\n    reset: store.reset,\n    nextState: store.nextState,\n  };\n}\n"],"names":["let","storeIdx","_setters","_nextStateResolvers","store","reset","_setAll","state","setState","Promise","resolve","push","actions","id","String","idx","_usedCount","onFirstUse","length","afterFirstMount","indexOf","afterEachMount","filter","setter","afterEachUnmount","autoReset","afterLastUnmount","newState","then","forEach","resolver","catch","e","useState","useDebugValue","useEffect","_subscribe","_unsubscribe","nextState"],"mappings":"4NACAA,IAAIC,EAAW,gBA0BR,yCACG,mCACE,sCACE,kSAMP,UAGDC,EAAW,GAEXC,EAAsB,GAIpBC,EAAQ,CAEZC,wBAAaC,EAAQC,IAErBA,MAAOA,EAEPC,SAAUF,8BAyBH,IAAIG,iBAAQC,GACjBP,EAAoBQ,KAAKD,cAtB3BE,EAEAC,GAAIC,OAAOD,YAAeZ,GAE1Bc,IAAKd,wBA2BaO,GACS,GAAvBJ,EAAMY,cACRC,IAEsB,IAApBf,EAASgB,QACXC,KAEkC,IAAhCjB,EAASkB,QAAQZ,KACnBN,EAASS,KAAKH,GACda,4BASkBb,GACpBN,EAAWA,EAASoB,gBAAOC,UAAUA,IAAWf,IAChDgB,IACwB,IAApBtB,EAASgB,SACPO,GACFrB,EAAMC,QAERqB,MA9CFV,WAAY,UAIPZ,WAmDEE,EAAQqB,GACS,mBAAbA,IACTA,EAAWA,EAASvB,EAAMG,QAI5BE,QAAQC,UACLkB,gBACCxB,EAAMG,MAAQoB,EACdzB,EAAS2B,iBAAQN,UAAUA,EAAOnB,EAAMG,SACxCJ,EAAoB0B,iBAAQC,UAAYA,EAAS1B,EAAMG,SACvDJ,EAAsB,KAEvB4B,eAAMC,SACCA,iBC5HP,SAAkB5B,SACF6B,WAAS7B,EAAMG,iBAEpC2B,gBAAc9B,GAEd+B,8BACE/B,EAAMgC,WAAW5B,qBACJJ,EAAMiC,aAAa7B,KAC/B,CAACJ,IAEG,CACLG,MAAOH,EAAMG,MACbK,QAASR,EAAMQ,QACfP,MAAOD,EAAMC,MACbiC,UAAWlC,EAAMkC"}