{"version":3,"file":"index.js","sources":["../src/createStore/createStore.js","../src/useStore/useStore.js"],"sourcesContent":["// an internal counter for stores\nlet storeIdx = 1;\n\n/**\n * Creates a new store\n * @param {Object} [config] - An object containing the store setup\n * @property {Object} [config.state] - The store's initial state. It can be of any type.\n * @property {Object} [config.actions] - Named functions that can be dispatched by name and payload.\n * @property {Boolean} [config.autoReset] - If true, reset the store when all consumer components unmount\n * @property {Function} [config.onFirstUse] - Callback the very first time a component calls useStore()\n * @property {Function} [config.afterFirstMount] - Callback when a useStore() component mounts when no other are mounted\n * @property {Function} [config.afterEachMount] - Callback every time a component first calls useStore()\n * @property {Function} [config.afterEachUnmount] - Callback when any useStore() component unmounts\n * @property {Function} [config.afterLastUnmount] - Callback when all user components unmount\n * @property {String} [config.id] - The id string for debugging\n * @return {Object} store - Info and methods for working with the store\n * @property {Function} store.state - the current state value\n * @property {Object} store.actions - Methods that can be called to affect state\n * @property {Function} store.setState - function to set a new state value\n * @property {Function} store.nextState - function that returns a Promise that resolves on next state value\n * @property {Function} store.reset - Reset the store's state to its original value\n * @property {String} store.id - The id or number of the store\n * @property {Number} store.idx - The index order of the store in order of definition\n * @property {Function} store._subscribe - A method to add a setState callback that should be notified on changes\n * @property {Function} store._unsubscribe - A method to remove a setState callback\n * @property {Number} store._usedCount - The number of components that have ever used this store\n */\nexport function createStore({\n  state = {},\n  actions = {},\n  autoReset = false,\n  onFirstUse = () => {},\n  afterFirstMount = () => {},\n  afterEachMount = () => {},\n  afterEachUnmount = () => {},\n  afterLastUnmount = () => {},\n  id = null,\n}) {\n  // list of setState functions for Components that use this store\n  const _setters = [];\n  // list of resolve functions for awaiting nextState\n  const _nextStateResolvers = [];\n\n  // define the store object,\n  // which should normally not be consumed directly\n  const store = {\n    // A store's state can be reset to its original value\n    reset: () => _setAll(state),\n    // the value represented\n    state: state,\n    // set the state and update all components that use this store\n    setState: _setAll,\n    // return a Promise that will be resolve on next state change\n    nextState,\n    // functions that act on state\n    actions,\n    // an identifier for debugging\n    id: String(id || `store-${storeIdx}`),\n    // internal counter\n    idx: storeIdx++,\n    // private: useStore() can subscribe to all store changes\n    _subscribe,\n    // private: useStore() can unsubscribe from changes\n    _unsubscribe,\n    // private: A count of the number of times this store has ever been used\n    _usedCount: 0,\n  };\n\n  // return this store\n  return store;\n\n  //\n  // functions only beyond this point\n  //\n\n  function nextState() {\n    return new Promise(resolve => {\n      _nextStateResolvers.push(resolve);\n    });\n  }\n\n  /**\n   * Add a setState function to notify when state changes\n   * @param {Function} setState - Function returned from the useState() inside useStore()\n   * @private\n   */\n  function _subscribe(setState) {\n    if (store._usedCount++ === 0) {\n      onFirstUse();\n    }\n    if (_setters.length === 0) {\n      afterFirstMount();\n    }\n    if (_setters.indexOf(setState) === -1) {\n      _setters.push(setState);\n      afterEachMount();\n    }\n  }\n\n  /**\n   * Remove a setState function from notification when state changes\n   * @param {Function} setState - Function returned from the useState() inside useStore()\n   * @private\n   */\n  function _unsubscribe(setState) {\n    const idx = _setters.indexOf(setState);\n    if (idx > -1) {\n      _setters.splice(idx, 1);\n    }\n    afterEachUnmount();\n    if (_setters.length === 0) {\n      if (autoReset) {\n        store.reset();\n      }\n      afterLastUnmount();\n    }\n  }\n\n  /**\n   * Notify each of the setState functions of the new state\n   * @param {*} newState\n   * @private\n   */\n  function _setAll(newState) {\n    if (typeof newState === 'function') {\n      newState = newState(store.state);\n    }\n    // queue state update for next tick\n    // see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask\n    Promise.resolve()\n      .then(() => {\n        store.state = newState;\n        _setters.forEach(setter => setter(store.state));\n        _nextStateResolvers.forEach(resolver => resolver(store.state));\n        _nextStateResolvers.length = 0;\n      })\n      .catch(e => {\n        throw e;\n      });\n  }\n}\n","import { useState, useEffect, useDebugValue } from 'react';\n\n/**\n * @param {Object} store - A store created with createStore()\n * @return {Object} - tools for working with the store\n * @property {*} state - The value in the store\n * @property {Object} actions - functions defined by createStore\n * @property {Function} reset - function to reset the store's state to its initial value\n * @property {Function} nextState - function that returns a Promise that resolves on next state value\n */\nexport function useStore(store) {\n  const [, setState] = useState(store.state);\n\n  useDebugValue(store);\n\n  useEffect(() => {\n    store._subscribe(setState);\n    return () => store._unsubscribe(setState);\n  }, [store]);\n\n  return {\n    state: store.state,\n    actions: store.actions,\n    reset: store.reset,\n    nextState: store.nextState,\n  };\n}\n"],"names":["storeIdx","state","actions","autoReset","onFirstUse","afterFirstMount","afterEachMount","afterEachUnmount","afterLastUnmount","id","_setters","_nextStateResolvers","store","reset","_setAll","setState","nextState","Promise","resolve","push","String","idx","_subscribe","_usedCount","length","indexOf","_unsubscribe","splice","newState","then","forEach","setter","resolver","e","useState","useDebugValue","useEffect"],"mappings":"uBACIA,EAAW,0CA2BbC,MAAAA,aAAQ,SACRC,YACAC,UAAAA,oBACAC,WAAAA,aAAa,mBACbC,gBAAAA,aAAkB,mBAClBC,eAAAA,aAAiB,mBACjBC,iBAAAA,aAAmB,mBACnBC,iBAAAA,aAAmB,mBACnBC,GAGMC,EAAW,GAEXC,EAAsB,GAItBC,EAAQ,CAEZC,MAAO,kBAAMC,EAAQb,IAErBA,MAAOA,EAEPc,SAAUD,EAEVE,UAsBF,WACE,WAAWC,QAAQ,SAAAC,GACjBP,EAAoBQ,KAAKD,MAtB3BhB,mBA1BQ,KA4BRO,GAAIW,mBArBD,kBAqBuBpB,GAE1BqB,IAAKrB,IAELsB,WAyBF,SAAoBP,GACS,GAAvBH,EAAMW,cACRnB,IAEsB,IAApBM,EAASc,QACXnB,KAEkC,IAAhCK,EAASe,QAAQV,KACnBL,EAASS,KAAKJ,GACdT,MAhCFoB,aAyCF,SAAsBX,GACpB,IAAMM,EAAMX,EAASe,QAAQV,GACzBM,GAAO,GACTX,EAASiB,OAAON,EAAK,GAEvBd,IACwB,IAApBG,EAASc,SACPrB,GACFS,EAAMC,QAERL,MAjDFe,WAAY,GAId,OAAOX,EAsDP,SAASE,EAAQc,GACS,mBAAbA,IACTA,EAAWA,EAAShB,EAAMX,QAI5BgB,QAAQC,UACLW,KAAK,WACJjB,EAAMX,MAAQ2B,EACdlB,EAASoB,QAAQ,SAAAC,UAAUA,EAAOnB,EAAMX,SACxCU,EAAoBmB,QAAQ,SAAAE,UAAYA,EAASpB,EAAMX,SACvDU,EAAoBa,OAAS,UAExB,SAAAS,GACL,MAAMA,gCC/HWrB,OACdG,EAAYmB,WAAStB,EAAMX,UASpC,OAPAkC,gBAAcvB,GAEdwB,YAAU,WAER,OADAxB,EAAMU,WAAWP,qBACJH,EAAMc,aAAaX,KAC/B,CAACH,IAEG,CACLX,MAAOW,EAAMX,MACbC,QAASU,EAAMV,QACfW,MAAOD,EAAMC,MACbG,UAAWJ,EAAMI"}